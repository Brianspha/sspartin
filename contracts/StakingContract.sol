pragma solidity >=0.8.0;
import "@chainlink/contracts/src/v0.8/dev/VRFConsumerBase.sol";
import "./SpartenToken.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
//SPDX-License-Identifier: UNLICENSED

contract StakingContract is VRFConsumerBase {
    using SafeMath
    for uint256;
 /*================================================== structs  start ==================================================*/

struct Session {
    string tokenURI;
    uint256 timeStart;
    uint256 timeEnd;
    uint256 sessionID; //@dev this is the random seed passed in by the user 
    uint256 difficultyIncrementor; //@dev generated by the chailink VFR
    bytes32 sessionRequestId; //@dev used to generate random number by the chainlink vfr
    uint256 tokenForGrabsValue; //@dev represents the token value to be issued to the a user this value is accumalation of all player fee in this round 
    uint256 ethStaked; //@dev represents the amount of eth staked so far from players
    uint256 tokenID;
    mapping (address=>Player) currentPlayers;
    address [] playerIDs;
    bool active;
    bool initialised;
    bool awaitingID; //@dev indicates if the session is awaiting the random difficulty incrementor to assigned or not
}

struct Player {
    address playerID;
    bytes32 [] sessions;
    bytes32 [] sessionsWon;
    bool active;
}

 /*================================================== events  start ==================================================*/
  event createdSession(uint256 indexed randomSeed,bytes32 indexed requestId);

 /*================================================== tokens  start ==================================================*/

SpartenToken erc721Token;

 /*================================================== storage  start ==================================================*/

bytes32 [] totalSessionsKeys;  //@dev represents all sessions which the contract has created
address [] playerKeys; //@dev represents all player keys that have played a game
mapping(address => Player) players; //@dev represents all players who have played the game
mapping(bytes32 => Session) sessions; //@dev represents all sessions that have been created
uint256 [] tokensIssued; //@dev represents all tokens which have been issued to winners 
 
 /*================================================== variables  start ==================================================*/

uint256 internal totalEarned;
address internal admin;
uint internal gameFeeCut=20 gwei; 
uint256 public constant roundDuration = 1 days;
uint256 public constant joinFee = 100 gwei;  // fee a user needs to pay to play
bytes32 internal parentKeyHash;
uint256 internal linkFee;
uint256 internal maxGamesPerDay = 10;
uint public currentSessions;
constructor(address erc721TokenAddress ,address vrfCoordinator, address linkToken,bytes32 keyHash) VRFConsumerBase(vrfCoordinator, linkToken) {
        require(erc721TokenAddress != address(0) || vrfCoordinator != address(0) || linkToken != address(0), "Zero address");
        //Randomness
        parentKeyHash = keyHash;
        linkFee = 0.1 * 10 ** 18;
        //init nft token
        erc721Token = SpartenToken(erc721TokenAddress);
        admin = msg.sender; //@dev assign contract admin
        totalEarned=0;
        currentSessions =0;
        totalEarned=0;
}

/*================================================== Game Functions start ==================================================*/
   /*** 
   * @dev the function is used to create a new game session
   @notice the token to be issued to a winner will be created once the random difficulty incrementor is generated by the chainlink vfr
    */
   
   function createNewGame(uint256 randomSeed,string memory tokenData) public payable {
       require(msg.value >= joinFee, "Amount must be equal to joining fee");
        require(currentSessions <= maxGamesPerDay, "Already reached max sessions for the day");
           bytes32 requestId = getRandomNumber(randomSeed);
    require(!sessions[requestId].initialised, "Session already initialised");
        if(msg.value > joinFee){
            uint256 extraFee = msg.value.sub(joinFee);
            uint256 normalFee = msg.value.sub(extraFee);
            uint256 tempGameCut = normalFee.sub(gameFeeCut);
            totalEarned = totalEarned.add(tempGameCut);///@dev incase the user sends more than the required joinfee
            sessions[requestId].ethStaked=sessions[requestId].ethStaked.add(normalFee.sub(tempGameCut));
        }
        else{
            uint256 tempGameCut = msg.value.sub(gameFeeCut);
            totalEarned = totalEarned.add(tempGameCut);
            sessions[requestId].ethStaked=sessions[requestId].ethStaked.add(msg.value.sub(tempGameCut));
        }
     sessions[requestId].tokenURI=tokenData;
       sessions[requestId].initialised=true;
       sessions[requestId].sessionID =randomSeed;
       sessions[requestId].awaitingID=true;
        sessions[requestId]. sessionRequestId=requestId;
        sessions[requestId].playerIDs.push(msg.sender);  
        sessions[requestId].currentPlayers[msg.sender].playerID=msg.sender;
        sessions[requestId].currentPlayers[msg.sender].sessions.push(requestId);
        sessions[requestId].currentPlayers[msg.sender].active = true;
        sessions[requestId].timeStart = block.timestamp;
        sessions[requestId].timeEnd = block.timestamp.add(roundDuration);
        sessions[requestId].awaitingID=true;
        sessions[requestId].initialised=true;
        currentSessions =currentSessions.add(1);
        players[msg.sender]= sessions[requestId].currentPlayers[msg.sender];
        totalSessionsKeys.push(requestId);
        totalSessionsKeys.push(requestId);
        playerKeys.push(msg.sender);
        emit createdSession(randomSeed,requestId);
   }


  /**================================================== Game Functions end ==================================================*/

  

  /**================================================== Chainlink Functions start ==================================================*/

 /** 
     * Requests randomness from a user-provided seed
     */
    function getRandomNumber(uint256 userProvidedSeed) public returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= linkFee, "Not enough LINK - fill contract with faucet");
        return requestRandomness(parentKeyHash, linkFee, userProvidedSeed);
    }

    /**
     * Callback function used by VRF Coordinator
     */
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        sessions[requestId].difficultyIncrementor=randomness;
        sessions[requestId].tokenID=erc721Token.mintToken(sessions[requestId].tokenURI,address(this));
        tokensIssued.push(sessions[requestId].tokenID);
        sessions[requestId].awaitingID=false;
        sessions[requestId].active=true;
    }
/*================================================== Chainlink Functions start ==================================================*/

  
}
